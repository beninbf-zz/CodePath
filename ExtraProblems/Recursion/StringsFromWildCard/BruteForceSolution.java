/**
 * *********************** PROBLEM DESCRIPTION ***************************
 * You are given string s of length n, having m WildCard characters '?', where each WildCard character represent
 * a single character. Write a program which returns all possible distinct strings valStr that can be generated by
 * replacing each WildCard characters in s with either a '0' or '1'.
 * Note that valStr doesn't contain any '?'
 */
import java.io.*;
import java.util.*;

class Result {

    // -------------------- START ----------------------
    static String[] find_all_possibilities(String s) {
        int n = s.length();
        char[] input = s.toCharArray();
        List<String> allStrings = new ArrayList<>();
        char[] current;
        long end = (1L << n);
        // Generating all possible binary arrays and matching it with given s, if suitable
        // match found then add to result list allStrings else not.
        for (int i = 0; i < end; i++) {
            current = getBinaryArray(i, n);
            if (checkIfMismatchOnlyAtWildCard(input, current)) {
                allStrings.add(new String(current));
            }
        }
        int count = allStrings.size();
        String result[] = new String[count];
        for(int i = 0; i < count; i++){
            result[i] = allStrings.get(i);
        }
        return result;
    }

    static boolean checkIfMismatchOnlyAtWildCard(char[] input, char[] current) {
        /*
         * To check whether input char array and current char array are matching at all indices
         * other than indices where character in input char array is '?'
         */
        for (int i = 0; i < input.length; i++) {
            if (input[i] == '?') {
                continue;
            }
            if (input[i] != current[i]) {
                return false;
            }
        }
        return true;
    }

    static char[] getBinaryArray(int x, int n) {
        /*
         * To generate binary array representing x padded with 0
         */
        char[] res = new char[n];
        for (int i = 0; i < n; i++) {
            res[n - 1 - i] = (char) ((((1L << i) & x) >> i) + '0');
        }
        return res;
    }

    // -------------------- END ----------------------
}

class Solution{
    public static void main(String args[]) {
        /*
        This function is used to increase the size of recursion stack. It makes the size of stack
        2^26 ~= 10^8
        */
        new Thread(null, new Runnable() {
            public void run() {
                try{
                    solve();
                }
                catch(Exception e){
                    e.printStackTrace();
                }
            }
        }, "1", 1 << 26).start();
    }
    public static void solve() throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(System.out));

        String s = bufferedReader.readLine().trim();

        String result[] = Result.find_all_possibilities(s);
        for (String str: result) {
            bufferedWriter.write(str+"\n");
        }

        bufferedWriter.close();

        bufferedReader.close();
    }

}

/**
 * Time complexity: O(n*(2^n))
 * Space complexity: O(n*(2^m))
 */
