Solution with time complexity O(a / b) and space complexity O(1) can be achieved using addition or subtraction.



We can divide our problem in four parts:

1) a >= 0 and b > 0

2) a < 0 and b > 0

3) a >= 0 and b < 0

4) a < 0 and b < 0



When a >= 0 and b > 0 then we can do something like this:



sum = 0

q = 0

while (sum + b <= a)

sum += b

q++

return q

  

Some modification in the above code will also work with other combinations. 



But still we can improve time complexity. 



Lets take a and b such that a % b = 0 so we can write q = a / b. q * b = a. To solve the problem thinking in terms of binary representation will help. 



q * b = q

(q31q30...q0) * b = a (in binary representation) 

(2^31 * q31 + 2^30 * q30 + ... + 2^0 * q0) * b = a 



To find value of each bit we can start from left side. 



First we try to set q31 = 1, if 2^31 * b <= a then we set q31 = 1, but if 2^31 * b > a then we set q31 = 0. 



When we set q31 = 0 then we have to solve 



(2^30 * q30 + ... + 2^0 * q0) * b = a



and when we set q31 = 1 then we have to solve 



(2^30 * q30 + ... + 2^0 * q0) * b = a - 2^31 * b.



Consider 37 / 3. We keep on left shifting divisor by 1 (multiply by 2) till it does not exceed 37, here it will be 3 -> 6 -> 12 -> 24. Now we can write our division 37 / 3 = (37 / (3 * 8)) * 8 + (37 - (3 * 8)) / 3. Now first part is (37 / 24) * 8 = 1 * 8 = 1 * 2^(number of shifts). Second part is 13 / 3 and this problem is smaller version of the same problem we are trying to solve.





We have provided 3 solutions, and all of them uses the same idea described above, but different implementations.



1) other_solution1.cpp: Recursive solution. 



Time complexity of the function is O(log(a) ^ 2). Recursive function can be called O(log(a)) times, and in each function call we are shifting no_of_shifts times that is O(log(a)). (Shift operation is considered as O(1).)



Auxiliary space and space complexity is O(log(a)) due to recursive function call. 



2) other_solution2.cpp: Iterative solution.



Time complexity of the function is O(log(a) ^ 2). Recursive function can be called O(log(a)) times, and in each function call we are shifting no_of_shifts times that is O(log(a)). (Shift operation is considered as O(1).)



Auxiliary space and space complexity is O(1).



3) optimal_solution.cpp: Iterative solution.



After some observations, in other_solution2.cpp we can notice that, value of variable no_of_shifts decreases always. Suppose it decreases like 60 -> 55 -> 50 -> ... -> 0. Then in other_solution2.cpp, we start no_of_shifts from 0 and increment it to 60, again for 55 we will increment no_of_shifts from 0 to 55. But as we know it will decrease from 60 to 55, we can directly start from 60 and quickly reach 55. Then from 55 to 50 (instead of 0 to 55)... After this optimization, overall we will do O(loga) shifts. 



Time complexity of the function is O(log(a) + log(a)) -> O(log(a)). (Shift operation is considered as O(1).)



Auxiliary space and space complexity is O(1).



If you are using C then direct copy pasting the code provided by us (which is in C++) will not work. In C abs(x) and fabs(x) are different. Use fabs instead of abs. 