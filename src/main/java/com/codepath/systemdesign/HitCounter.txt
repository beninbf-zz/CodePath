/*

// Count the number of hits in the past 5 mins
// hit(1)
// hit(2)
// hit(3)
// getHits(4) => 3
// hit(300)
// getHits(300) => 4
// getHits(301)  => 3

There are two main wrinkles to this problem. My first solution
just using a list or a queue to store the timestamps, and them removing
the head of the list if the time gap is larger than 5 mins. This works
if the timestamps come in increasing order.

however, what if timestamps come in out of order due to latency. So
hit(300) could come, and then hit(5) after. How do we return ONLY
the count of things that occured in the last 5 mins?

We must realize that we ONLY need the last 300 entries. This should
be a give away to use an array. In order to accommodate time stamps
above 300, like say 405, we take the modulus, 405 % 300, which will
map to index 105. However, we have no way of associating a hit
with a timestamp, because we are only using an array to store counts
within the last 300 seconds.

We are using Two arrays. Both of length 300, one hits, is used to store
the counts at a given index, where the index is timestamp % length.

The other array is time, where the index is the timestamp % length, but the
value stored at the index is timestamp associated with the latest hit

time[105] = 105, or time[105] = 405.

we use time array, to know when the counts are wrapping. When they wrap, we reset the value at
index to 1, and update the time array. If another hit comes in at the same timestamp, then
we simply increment.

When get hit is called, we do a sum over the array for values within the 300 range.

Scaling this for multiple processes would require using some kind of lock, so that
we can prevent one thread from reading a value with another thread is changing the value.

Scaling this for distributed machines would require aggregating the counts, when get
hit is called.

Accumulate the hits as this function is called.
for every time the function hit is called, I want to check the incoming timestamp
against, the first hit, check to see if the difference between the two
is greater than, this 5 minute

hit(1) -> hit(2) -> hit(3) -> hit(300) -> hit(302)

compare the timestamp of hit(302) with the head of the list, and if the magnitude of diff
is greater than 5 mins, then expel,

while (Math.abs(hit.timestamp - head.timestamp) > 5 * MIN) {

   list.set(0, )

}


// 250, 234, 200, 301, 45, 10

// count: 1, 2, 3
// 250 max, 234, 200 min, 305

405 % 300 = 105...405 - 105 > 5 Mins, current count at index 105 = 1

// 105 -> (405, 405, 405, 405)

class HitCounter
{

 private final int MIN = 60;

 int[] hits = new int[300];
 int[] times = new int[300];
 void hit(int timestamp) {

     int index = timestamp % hits.length;
     if (times[index] != timestamp)    // times[105] = 105
     {
         times[index] = timestamp;
         hits[index] = 1;
     }
     else
     {
         hits[index]++;
     }

   }

int getHits(int timestamp) {
       int result = 0;
       for (int i = 0; i < hits.length; i++) {
           if (timestamp - times[i] < 300) {
              result+=hits[i];
            }
        }
        return result;
    }
  };
    */


*/